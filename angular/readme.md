# Angular

## Timeline

![Timeline](timeline-angular-js.jpg)
ref(https://www.bootstrapdash.com/angular-release-date/)

Une version a tous les 6 moins
** Compatibilit√© conserv√© entre chaque rel√¢che **

## Quelques notes historiques

üåø La confusion Angular?

La plupart des gens connaissaient la premi√®re version d'Angular sous le nom d'Angular 1; il est devenu plus tard connu sous le nom d'AngularJS, mais beaucoup l'appellent encore Angular 1. Il n'utilisait pas le contr√¥le de version s√©mantique.

üåø  Puis Angular 2 est arriv√©, et en 2016, il a atteint sa capacit√© de production. Angular a d√©cid√© d'adopter le versionnage s√©mantique, ce qui a caus√© un peu de confusion dans la communaut√© des d√©veloppeurs, surtout quand il a annonc√© qu'il y aurait un Angular 4 et 5 et ainsi de suite. 

üåø L'√©quipe Angular, ainsi que le r√©seau de leurs experts en d√©veloppement Google, ont commenc√© √† expliquer que nous devrions appeler la derni√®re version du framework Angular, juste Angular. 

üåø Vous pouvez faire valoir la sagesse de cette d√©cision. Il n'en reste pas moins que le nouvel Angular utilise le versionnage s√©mantique, ce qui signifie qu'Angular est la m√™me plate-forme qu'Angular 2, ainsi qu'Angular 10, et ainsi de suite. 

***
üåø Angular repr√©sente une r√©√©criture compl√®te du framework AngularJS, introduisant une toute nouvelle architecture d'application construite enti√®rement √† partir de z√©ro en TypeScript, un sur-ensemble strict de JavaScript qui ajoute le typage statique facultatif et la prise en charge des interfaces et des d√©corateurs.

üåø En un mot, les applications angulaires sont bas√©es sur une conception d'architecture qui comprend des arbres de composants Web interconnect√©s par leur interface d'E/S particuli√®re. Sous le capot, chaque composant profite d'un m√©canisme **d'injection de d√©pendance** (IOC: Inverse Of Control) enti√®rement repens√©.

üåø Pour √™tre juste, il s'agit d'une description simpliste de ce qu'est r√©ellement Angular; 

***
# Configuration
#### Pr√©-requis

#### üåº Node.js
>Node.js est un moteur d'ex√©cution JavaScript bas√© sur le moteur JavaScript v8 de Chrome. Angular n√©cessite une version actuelle ou LTS. Si vous l'avez d√©j√† install√©, vous pouvez ex√©cuter node -v dans la ligne de commande pour v√©rifier la version que vous utilisez. 
Sinon, vous pouvez l'obtenir sur https://nodejs.org.
Angular **CLI**utilise **Node.js** pour accomplir des t√¢ches sp√©cifiques, telles que le service, la cr√©ation et le regroupement de votre application.

#### üåº Npm
>Npm est un gestionnaire de progiciels inclus par d√©faut dans Node.js. Vous pouvez v√©rifier cela en ex√©cutant **npm -v** dans la ligne de commande. Le framework Angular est un √©cosyst√®me de diverses biblioth√®ques, appel√©es packages, qui sont disponibles dans un emplacement central appel√© registre **npm**. Le client **npm**t√©l√©charge et installe les biblioth√®ques n√©cessaires pour ex√©cuter votre application √† partir du registre.

#### üåº Git
>Git est un client qui nous permet de nous connecter √† des syst√®mes de contr√¥le de version distribu√©s, tels que GitHub, Bitbucket et GitLab. Il est facultatif du point de vue de la CLI angulaire. Vous devriez l'installer au cas o√π vous voudriez t√©l√©charger votre projet Angular dans un r√©f√©rentiel Git, ce que vous voudrez peut-√™tre faire.

***
#### üåº Installation Angular CLI (Command Line Interface)
La CLI Angular fait partie de l'√©cosyst√®me Angular et est disponible au t√©l√©chargement √† partir du registre de packages npm. Puisqu'il est utilis√© pour cr√©er des applications et des projets angulaires, nous devons l'installer globalement dans notre syst√®me. Ouvrez un terminal et ex√©cutez la commande suivante:
> * npm install -g @angular/cli

#### Les commandes CLI
üî∏ [Lien vers un fichier PDF contenant des commandes](angular_cli_commands.pdf)

# Tour d'horizon d'Angular

## Fichier initiaux

Lorsqu'on cr√©e un projet Angular il y a les √©l√©ments suivant qui sont cr√©es

```shell
ng new empty
? Would you like to add Angular routing? No
? Which stylesheet format would you like to use? CSS
CREATE empty/angular.json (3033 bytes)
CREATE empty/package.json (1067 bytes)
CREATE empty/README.md (1051 bytes)   
CREATE empty/tsconfig.json (783 bytes)
CREATE empty/.editorconfig (274 bytes)
CREATE empty/.gitignore (604 bytes)
CREATE empty/.browserslistrc (703 bytes)
CREATE empty/karma.conf.js (1422 bytes)
CREATE empty/tsconfig.app.json (287 bytes)
CREATE empty/tsconfig.spec.json (333 bytes)
CREATE empty/src/favicon.ico (948 bytes)
CREATE empty/src/index.html (291 bytes)
CREATE empty/src/main.ts (372 bytes)
CREATE empty/src/polyfills.ts (2820 bytes)
CREATE empty/src/styles.css (80 bytes)
CREATE empty/src/test.ts (788 bytes)
CREATE empty/src/assets/.gitkeep (0 bytes)
CREATE empty/src/environments/environment.prod.ts (51 bytes)
CREATE empty/src/environments/environment.ts (658 bytes)
CREATE empty/src/app/app.module.ts (314 bytes)
CREATE empty/src/app/app.component.html (24585 bytes)
CREATE empty/src/app/app.component.spec.ts (953 bytes)
CREATE empty/src/app/app.component.ts (209 bytes)
CREATE empty/src/app/app.component.css (0 bytes)
```

## Modules

Cr√©er un module ajoute 4 fichier du nom du component que l'on ajoute

```shell
ng g c newcomponent
CREATE src/app/newcomponent/newcomponent.component.html (27 bytes)
CREATE src/app/newcomponent/newcomponent.component.spec.ts (668 bytes)
CREATE src/app/newcomponent/newcomponent.component.ts (299 bytes)
CREATE src/app/newcomponent/newcomponent.component.css (0 bytes)
UPDATE src/app/app.module.ts (420 bytes)
```

## Model

Par convention on cr√©e un r√©pertoire model pour contenir notre d√©finition de model pour notre application

## Service

Un r√©pertoire service pourra √™tre cr√©e pour inclure notre code d'interface pour nos composante et le model

# MVC

üåø Component, Templates, Interpolation, et Directives ?

![](Im-01.jpg)

*** 
üåø Exemple d'architecture d'une application Angular 10.
![](Im-02.jpg)

üåº  Nous allons cr√©er l'interface utilisateur √† l'aide de mod√®les, de directives et de liaisons de donn√©es. 

üåº   Angular nous donne la liaison de donn√©es afin que nous puissions facilement afficher des informations et r√©pondre aux actions de l'utilisateur. Avec les directives angulaires, nous ajoutons une logique √† notre code HTML, telle que les instructions if et les boucles for. 

üåº Et avec les composants Angular, nous construirons des fragments d'interface utilisateur imbriqu√©s (ex : Images).

üåº Nous avons vu qu'un composant angulaire est une vue d√©finie avec un mod√®le, son code associ√© d√©fini avec une classe et des informations suppl√©mentaires d√©finies avec des m√©tadonn√©es et d√©finies √† l'aide d'un d√©corateur de composant. 

# Application Angular

Regardons les bases d'une application angular

## empty

Allons dans le folder `empty` et roulons ng serve. Ouvrir un browser sur [http://localhost:4200/]

La page est vide yeah!

* Ajoutons du html dans app.components.html
* Le Html apparait
  * mais! pourquoi? est-ce notre index.html?
  * component vs selector vs attribute vs class vs id
  * View source (Regardons le flow)
    * index + script
    * load main.ts
    * load app modules
    * load app components
    * load ... (DOM rewrite)


üåø Quelques d√©finitions

üåø  **L'interpolation** (contr√¥le des attributs) : La syntaxe d'interpolation permet d'acc√©der directement aux propri√©t√©s du composant associ√© (un peu comme si toutes les expressions √©taient pr√©fix√©es par un this . 
Exemples üëç 
* **`{{ titre }}`**
* **`<h1>{{ titre }}</h1>`**
* **`{{'Titre: ' + titre }}`**
* **`{{ 2*20+1 }}`**
* **`{{ 'Titre: ' + getTitre() }}`**
* **`<h1 innerText={{pageTitre}}></h1>`**

### Exercise : Premier pas
> * Cr√©er une application Angular
> * Ajoutez le module bootstrap
>   * Utiliser npm pour ajouter bootstrap dans le r√©pertoire node_modules `npm install bootstrap`
>   * Dans le fichier angular.json dans la section css ajouter `node_modules/bootstrap/dist/css/bootstrap.css`
> ![](bootstrapcss.png)
> * Dans votre app.component.html vous pouvez utiliser bootstrap pour contoller la structure de votre page et de ses √©l√©ments.
> * Dans la class AppComponent (app.component.ts)
> * Cr√©ez une variable avec une chaine de text
> * Mettre du HTML dans le app.component.html pour afficher le contenu de votre variable

DIDIER: Group 1 est ici

# Les directives

[Documentation](https://angular.io/guide/built-in-directives)

![](Im-03.jpg)

üåº Alors que le **`Template `**Interpolation et la propri√©t√© **`Binding `**permettent de modifier l'affichage et le contenu, ils ne permettent pas de modifier la structure du DOM en ajoutant ou en retirant des √©l√©ments par exemple.

üåº Pour rem√©dier √† cette limitation, Angular fournit des directives structurelles qui permettent de modifier la structure du **`DOM`**.

> Les directives que nous allons utiliser existes dans le framework angular. Cependant il est possible de cr√©er des directives avec le decorateur  `@Directive`

```Typescript
@Directive({
    selector: '[myDirective]'
})
export class LeCodeDeMaDirective {
    ...
}
```

### **Directive NgIf**

üåº L'une de ces directives les plus utilis√©es est le **`NgIf`**. Si l'expression associ√©e √† la directive est **`false `**alors l'√©l√©ment et son contenu sont retir√©s du **`DOM`** (ou jamais ajout√©s).

**`<button *ngIf="isAvailable">OUVERT</button>`**

**`export class AppComponent {`**
    **`isAvailable = false;`**
**`}`**

**[NgIf Angular documentation](https://angular.io/api/common/NgIf)**

**[switch Angular documentation](https://angular.io/api/common/NgSwitch)**

### Exercise : 
> * Ajouter un booleen dans le appcomponent.ts de l'exercise pr√©c√©dant et affichez du contenue si le booleen est vrai ou faux

üåº **Directive NgFor**

La directive structurelle NgFor permet de boucler sur un tableau et d'injecter les √©l√©ments dans le DOM.

üåø  **Dans la vue**

```html
<ul>
    <li *ngFor="let livre of listeLivres">{{ livre.titre}}</li>
</ul>
```

üåø  **Dans le composant**

```typescript
listeLivres = [
        {
            titre: 'Angular 10'
        },
        {
            titre: 'Java 8'
        }
    ];
```

### Exercise : 

Toujours en utilisant le projet que vous avez cr√©e ajouter les √©l√©ments suivants:

> * Cr√©ez un vecteur de avec la liste de livres affiche plus haut
> * En utilisant la directive NGfor affichez votre liste de livre

# Components

[Documentation](https://angular.io/guide/component-overview)

Une application est construite en "component" chaque components peuvent √™tre group√©s pour contruire une application.

Example l'application pour le TP final aura plusieurs "components" qui servirons √† la cr√©ation de l'application.

DIDIER: Group 2 est ici

### Exercise : Component

On va ajouter deux composants √† l'int√©rieur notre exercise initial. 

> * Creez un component en utilisant le CLI:
>   * `ng generate component alpha`
> * Modifier le html de votre component pour y mettre du html
> * Verifier dans votre application si vous voyez le text de votre nouveau component
> * Ajouter une r√©f√©rence a votre component dans le app.component.html
> * Creez un autre component beta **mais sans utiliser la commande ng** r√©f√©rez-vous au premier component pour voir ce que vous devez ajouter.
>   * Ici le but est de regarder les fichiers qui furent cr√©es pour le project Alpha et cr√©e des fichiers similaire pour contruire un component beta
>   * Il va y avoir un fichier qui a re√ßu une autre modification pour inclure le nouveau module, vous devrez le trouver et le modifier pour ajouter votre module beta.
> * Dans le component alpha, affichez le contenue du component beta 2 ou trois fois

## @component

* Selector
  * Nom de notre component
* templateUrl
  * Location de notre template HTML
  * On peut le remplacer par template avec du HTML
    * '' vs ``
* styleUrls
  * Vecteur des fichiers CSS pour notre component

# Styling using CSS

Chaques components peuvent inclure du CSS pour ajuster le style pour les √©l√©ments du component.

### Exercise

> * En ajoutant √† l'int√©rieur du fichier CSS pour le composant Alpha changer le stype pour p ou h1 pour mettre un background color bleu
> * Observer la couleur dans votre application
>   * Est-ce que la couleur que vous avez mis dans le component alpha impact le component beta qui est affich√© dans Alpha?
> * A l'interieur de Beta en remplacant le @component pour utiliser style au lieu de style URL et changer le background color red.
> * Observez le r√©sultat
> * Question pourquoi il n'y a pas de conflit pour les styles?

### Exercise: [resultats](exercises/resultats)

# Debut livre de recette

Pour Didier: https://github.com/didiertremblay/recettes/compare/v0...v8

Dans le r√©pertoire angular un r√©pertoire recettes contient le d√©but de l'application livre de recette qui sera vu en classe pour int√©grer les notions angular dans une application. 

Pour √©x√©cut√© en local le code d√©pos√© vous devrez installer le d√©pendance pour npm en executant la commande `npm i`. Par la suite vous pourrez d√©marrer le serveur en utilisant `ng serve`

### Exercise: Suivant la meme structure cr√©ez un application affichant un journal de voyage.

> * Creez le git `pratique-pour-tp` un nouveau projet Angular
> * Cr√©ez un repertoire model dans lequel vous allez mettre le model que vous avez cr√©√© dans un exercise pr√©c√©dent pour le **Journal de voyage**
>   * Voir [Recettes](../typescript/exercises/Recettes/readme.md)
> * Cr√©ez une premiere version ou vous affichez une vue des diff√©rents voyages. Vous n'avez pas a vous pr√©occup√© de la forme juste afficher les informations sommaire et pas besoin d'images pour le moment. Aux cours des differents cours vous aurez l'occasion de modifier cette base en une application plus fonctionnel.

> **Pour le journal de voyage, il n'y aura pas de corrig√© fourni. Cette composante est un √©l√©ment qui fait parti du TP final et sera √† int√©grer et √©valuer avec le travail de fin d'ann√©e.** 

# Bindings

"Bindings" permet de specifier un lien entre Angular entre les variables de notre class et le template. L'interpolation `{{}}` vu pr√©c√©dement

Affichage des informations

```shell
                       Interpolation
<typescript>             {{abc}}             
eg AppComponent class   =========>     html/Template
                      [property]="data"
                      Property Binding
```

Recevoir des informations

```shell
                       Event Binding
<typescript>          (event)="expression"        
eg AppComponent class   <========     html/Template
```

Recevoir des informations

```shell
                       Event Binding
<typescript>          (event)="expression"        
eg AppComponent class   <========     html/Template
```

Exchange bi directionel

Recevoir des informations

```shell
                          To Way Binding
<typescript>            [(ngModel)]="data"        
eg AppComponent class       <========        html/Template
```

### Exercise : Binding

On a fait pr√©c√©dament un affichage de nos variables dans notre module. 

> * Comment rendre ce bouton disabled avec une variable.
>   * Cr√©ez une variable bouton_actif qui est mis a false
>   * Dans notre constructeur appelez la function setTimeout pour changer l'√©tat de la variable a true (!!! important utiliser un arrow function sinon votre this pour votre constructeur ne fonctionnera pas!!!)
> * Dans le app.component.html de cette exercise ajoutons deux boutons
>   * Mettre le premier bouton disabled
>   * Mettre le deuxieme bouton disabled={{bouton_actif}}
>       * Ce binding permet de lier un property avec une expression typescript.
>   * Le property pourrait aussi √™tre utilis√© pour afficher le text d'un √©l√©ment avec `<p [innerText]="bouton_actif"></p>`

### Exercise : Event Binding

Ici nous allons capturer une action sur notre bouton pour engendrer un changement dans notre application.

> * Maintenant on va faire quelquechose avec notre bouton lorsqu'il est actif
> * Dans notre deuxieme bouton ajouter `(click)="onButtonClick()"
> * Dans votre class application cr√©e un m√©thod onButtonClick qui change une variable dans votre code

Tous les types d'√©v√©nement javascript peuvent √™tre utilis√© et dans les scenarios ou les √©v√©nements poss√®de des donn√©es ces donn√©es sont disponible par la variable `$event`

> * Ajoutez un `input` pour du texte
> * Dans cet `input` ajoutez le event binding pour input `(input)="inputOfText($event)`
> * Cr√©ez une fonction qui affiche le contenu du parametre recu (Utilis√© any comme type)
>   * Si on veut √©viter Le type any pour cette √©venement est un Event.. L'utiliser cependant requiert d'utiliser un casting `HTMLInputElement` 
> * Afficher le contenu de l'√©v√©nement dans le console log.
> * Prendre la valeur de l'input et la mettre dans une variable que vous avez cr√©e pr√©c√©dament pour y voir le texte que vous entrez.

### Exercise: Two way binding

[Documentation](https://angular.io/guide/two-way-binding#how-two-way-binding-works)

Souvent l'information captur√© doit √™tre r√©utilis√© pour mettre √† jour un √©l√©ment dans le template. Dans ce scenario nous relions la template avec une variable ainsi que la variable avec la template.

> * Cr√©ez un nouvel `input` pour ajouter du texte
> * Dans cet `input` ajoutez un two way binding en utilisant `[(ngModel)]="variable"` ou variable est la variable que vous avez utlis√© dans l'exercise pr√©c√©dent.
>   * ngModel ne sera pas reconnu et doit √™tre ajouter dans appModule

![](ngFormAppModule.png)

> * Cr√©ez un nouvel `input` pour ajouter du texte

Est-ce que tout fonctionne???? Qu'elle est la difference entre nos deux inputs?

### Exercise : [Binding](angulare/exercises/binding)

# DIDIER: TO WORK ON THE NEXT STEPS

# Passage de parametre entre components

Jusqu'√† pr√©sent nous avons vu que nous pouvons cr√©er plusieurs components et avoir un component utilis√© un autre component. Cependant notre utilisation de l'autre component se limite √† afficher simplement son contenu. Comment utiliser le component pour lui demander d'afficher de l'information fournis par le parent?

Pour faire ce passage d'information angular fournit le d√©corateur `@input` [Documentation](https://angular.io/guide/inputs-outputs)

DIDIER: https://github.com/didiertremblay/recettes/compare/v8...v9

Pour d√©montrer ce processus nous allons modifier l'application de recettes pour cr√©er un nouveau component qui aura comme responsabilit√© d'afficher un sommaire pour une recette.

> * Cr√©ons un component sommaire-recette
> * Dans sommaire-recette nous allons ajouter un attribut recette pour lequel nous allons d√©cor√© de `@Input()` pour lui permettre de recevoir l'information de sont parent
> * On va d√©plac√© le contenu qui correspond au sommaire dans le html du nouveau component
> * Ainsi que le CSS requis pour l'imgae
> * Dans le parent au lieu du sommaire on va utiliser le selecteur de notre nouveau component en passant notre recette qui est a afficher `[recette]="recette` (Hum?! meme nom :()

Donc

### Exercise, faire la m√™me transformation avec votre Journal de voyage.




## DIDIER TO ADD Cover

- [ ] ngStyle
- [ ] ngClass
- [ ] Distribuer l'avancement du livre de recette
- [ ] Barre de navigation
- [ ] Model
- [ ] Directive
- [ ] CSS
- [ ] Form Validation methods
- [ ] Service
- [ ] Event Emitter
- [ ] Observable
- [ ] RxJS - Chat app?
  - [ ] Mouse move?
- [ ] Filter | Pipe
- [ ] Testing



# NE PAS CONTINUER DOIS ETRE AJUST√â
# NE PAS CONTINUER DOIS ETRE AJUST√â
# NE PAS CONTINUER DOIS ETRE AJUST√â
# NE PAS CONTINUER DOIS ETRE AJUST√â

üåø Le but des services d'Angular 

Les services angulaires sont des objets **Singleton** qui ne sont instanci√©s qu'une seule fois pendant la dur√©e de vie d'une application. Ils contiennent des m√©thodes qui conservent les donn√©es tout au long de la vie d'une application, c'est-√†-dire que les donn√©es ne sont pas actualis√©es et sont disponibles √† tout moment. 

üåø L'objectif principal d'un service est d'organiser et de partager la logique m√©tier, les mod√®les ou les donn√©es et fonctions avec diff√©rents composants d'une application Angular.

üåø Pourquoi utiliser les services en Angular?
La s√©paration des pr√©occupations (besoins ou exigences) est la principale raison pour laquelle les services angulaires ont vu le jour. Un service Angular est un objet sans √©tat et fournit des fonctions tr√®s utiles. Ces fonctions peuvent √™tre appel√©es √† partir de n'importe quel composant d'Angular, comme les contr√¥leurs, les directives, etc. Cela aide √† diviser l'application Web en petites unit√©s logiques diff√©rentes qui peuvent √™tre r√©utilis√©es.

üåø Par exemple : Une application Angular peut avoir plusieurs contr√¥leurs (, pour r√©cup√©rer les donn√©es requises par l'ensemble de l'application. Faire un appel AJAX au serveur √† partir du contr√¥leur est redondant, car chaque contr√¥leur utilisera un code similaire pour faire un appel pour les m√™mes donn√©es. 

üåø Dans de tels cas, il est extr√™mement utile d'utiliser un service, car nous pouvons √©crire un service contenant le code pour r√©cup√©rer les donn√©es du serveur et injecter le service dans le contr√¥leur. 

üåø Les services auront des fonctions pour passer un appel. Nous pouvons utiliser ces fonctions de services dans le contr√¥leur et faire des appels au serveur, de cette fa√ßon nous n'avons pas besoin d'√©crire √† nouveau le m√™me code et il peut √©galement √™tre utilis√© dans des composants autres que les contr√¥leurs. De plus, les responsables du traitement n'ont plus √† effectuer la t√¢che de r√©cup√©ration des donn√©es, car les services s'en chargent, atteignant ainsi l'objectif de s√©paration des pr√©occupations.

***

üåø Qu‚Äôest-ce qu‚Äôun patron de conception (Design Pattern)‚ÄØ?

üåº Les patrons de conception sont des solutions classiques √† des probl√®mes r√©currents de la conception de logiciels. Ce sont des sortes de plans ou de sch√©mas que l‚Äôon peut personnaliser afin de r√©soudre un probl√®me r√©current dans notre code.

üåº Vous ne pouvez pas vous contenter de trouver un patron et de le recopier dans votre programme comme vous le feriez avec des fonctions ou des librairies pr√™tes √† l‚Äôemploi. Un patron, ce n‚Äôest pas un bout de code sp√©cifique, mais plut√¥t un concept g√©n√©ral pour r√©soudre un probl√®me pr√©cis. Vous pouvez suivre le principe du patron et impl√©menter une solution qui convient √† votre propre programme.

üåº Les patrons sont souvent confondus avec les algorithmes, car ils d√©crivent tous deux des solutions classiques √† des probl√®mes connus. Un algorithme d√©finit toujours clairement un ensemble d‚Äôactions qui va vous mener vers un objectif, alors qu‚Äôun patron, c‚Äôest la description d‚Äôune solution √† un plus haut niveau. Le code utilis√© pour impl√©menter un m√™me patron peut √™tre compl√®tement diff√©rent s‚Äôil est appliqu√© √† deux programmes distincts.

üåº Un algorithme c‚Äôest un peu comme une recette de cuisine, ses √©tapes sont claires et vous guident vers un objectif pr√©cis. 

üåº Un patron, c‚Äôest plut√¥t comme un plan : vous pouvez voir ses fonctionnalit√©s et les r√©sultats obtenus, mais la mani√®re de l‚Äôimpl√©menter vous revient.

üåø Que trouve-t-on dans un patron de conception‚ÄØ?

üåº La majorit√© des patrons sont pr√©sent√©s de fa√ßon tr√®s g√©n√©rale, afin qu‚Äôils soient reproductibles dans tous les contextes. Voici les diff√©rentes sections que vous retrouverez habituellement dans la description d‚Äôun patron :

* L‚ÄôIntention du patron permet de d√©crire bri√®vement le probl√®me et la solution.
* La Motivation explique en d√©tail la probl√©matique et la solution offerte par le patron.
* La Structure des classes montre les diff√©rentes parties du patron et leurs relations.
* L‚ÄôExemple de code √©crit dans un des langages de programmation les plus populaires facilite la compr√©hension g√©n√©rale de l‚Äôid√©e derri√®re le patron.

***
* üçÑ  [Exercice1](#Th√©orie)
***

* D√©finir Angular ?
* D√©crivez bri√®vement l‚Äôarchitecture d‚Äôun projet Angular 10 ?
* Expliquez bri√®vement (clairement) le r√¥le du fichier ¬´ package.json ¬ª?
* Expliquez bri√®vement (clairement) le r√¥le du fichier ¬´ angular.json ¬ª?
* D√©finir les termes suivants :
  * Selector 
  * templateUrl 
  * template
  * styleUrls 
  * style
* Quel est le r√¥le de NPM?
* Quels sont les avantages de l'utilisation d'Angular?
* √Ä quoi sert Angular principalement ?
* Quelles sont les expressions angulaires?
* Expliquez les interpolations ?

***
[Aide m√©moire Angular 10](dzone-refcard206-angular.pdf)


### Introduction au routeur Angular

üåº Dans les applications Web traditionnelles, lorsque nous voulions passer d'une vue √† une autre, nous devions demander une nouvelle page au serveur. Le navigateur cr√©erait une URL pour la vue et l'envoyait au serveur. 

‚ô£Ô∏è D√®s qu'une r√©ponse √©tait re√ßue du serveur, le navigateur rechargeait la page. Ce processus a entra√Æn√© des retards aller-retour et une mauvaise exp√©rience utilisateur pour nos applications :

![](Capture.jfif)

‚ô£Ô∏è Le framework Angular fournit le package npm @angular/router, que nous pouvons utiliser pour naviguer entre diff√©rents composants dans une application Angular 10. L'ajout d'un routage dans une application angulaire implique les √©tapes suivantes :

1. Sp√©cifiez le chemin d'acc√®s de base de l'application Angular.
2. Utilisez un module angulaire appropri√© du package @angular/router.
3. Configurez diff√©rentes routes pour l'application Angular.
4. D√©cidez o√π orienter (diriger) les composants lors de la navigation.
 
üî∏ Les applications Web modernes qui utilisent un framework JavaScript tel que Angular suivent une approche diff√©rente. Ils g√®rent les changements entre 
   les vues ou les composants c√¥t√© client sans d√©ranger le serveur. Ils ne contactent le serveur qu'une seule fois lors du d√©marrage pour obtenir le 
   fichier principal index.html. Toutes les modifications ult√©rieures d'URL sont intercept√©es et g√©r√©es par le routeur sur le client. Ces types 
   d'applications sont appel√©es applications √† page unique (SPA) car ils ne provoquent pas un rechargement complet d'une page :

![](routeur2.jfif)

***
# point-2
### Sp√©cification

> Comme nous l'avons d√©j√† vu, les applications Web modernes et traditionnelles r√©agissent diff√©remment lorsqu'une URL change dans l'application. 
> L'architecture de chaque navigateur joue un r√¥le essentiel dans ce comportement. 

> Les navigateurs plus anciens lancent une nouvelle requ√™te au serveur lorsque l'URL change. 

> Les navigateurs modernes, √©galement appel√©s navigateurs HTML5, peuvent modifier l'URL et l'historique du navigateur, lors de la navigation dans diff√©rentes vues, sans envoyer de requ√™te au serveur en utilisant une technique appel√©e HTML5 pushState.

```typescript
HTML5 pushState permet la navigation dans l'application sans provoquer un rechargement complet 
de la page et est pris en charge par tous les navigateurs modernes.
```
Une application Angular doit d√©finir la balise HTML de base dans le fichier index.html pour activer le routage pushState :

```html
<!doctype¬†html>
<html¬†lang="en">
<head>
¬†¬†<meta¬†charset="utf-8">
¬†¬†<title>MyApp</title>
¬†¬†<base¬†href="/">
¬†¬†<meta¬†name="viewport"¬†content="width=device-width,¬†¬†¬†initial-scale=1">
¬†¬†<link¬†rel="icon"¬†type="image/x-icon"¬†href="favicon.ico">
</head>
<body>
¬†¬†<app-root></app-root>
</body>
</html>
```

üåº L'attribut **href** informe le navigateur sur le chemin qu'il doit suivre lorsqu'il tente de charger des ressources externes, telles que des fichiers multim√©dias ou CSS, une fois qu'il va plus loin dans la hi√©rarchie des URL.

üåº La CLI Angular ajoute la balise de base par d√©faut lors de la cr√©ation d'une nouvelle application Angular et d√©finit la valeur **href* sur la racine de l'application, /. Si votre application r√©side dans un dossier diff√©rent de celui de l'application, vous devez la modifier en fonction du nom de ce dossier.

# point-3
### Importation du module routeur
La biblioth√®que de routeurs angulaires contient RouterModule, un module angulaire que nous devons importer dans notre application pour commencer √† utiliser les fonctionnalit√©s de routage :

```typescript
import¬†{¬†RouterModule¬†}¬†from¬†'@angular/router';
```
Nous importons RouterModule dans le module d'application principal, AppModule, en utilisant le mod√®le forRoot

```typescript
@NgModule({
¬†¬†imports:¬†[
¬†¬†¬†¬†RouterModule.forRoot(routes)
¬†¬†]
})
```
La m√©thode forRoot de RouterModule renvoie un module angulaire qui contient un ensemble d'artefacts angulaires li√©s au routage :

* Services pour effectuer des t√¢ches de routage courantes telles que la navigation
* Directives que nous pouvons utiliser dans nos composants pour les enrichir avec une logique de navigation

Il accepte un seul param√®tre, qui est la configuration d'itin√©raire de l'application.

# point-4
### Configurer le routeur
La variable routes que nous transmettons dans la m√©thode forRoot est une liste d'objets Routes qui sp√©cifient les routes existantes dans l'application et les composants qui doivent r√©pondre √† une route sp√©cifique. Cela peut ressembler √† ceci :

```typescript
const¬†routes:¬†Routes¬†=¬†[
¬†¬†{¬†path:¬†'listes',¬†component:¬†ListesComponent¬†},
¬†¬†{¬†path:¬†'**',¬†component:¬†PageNotFoundComponent¬†}
];
```

Chaque objet de d√©finition de route contient une propri√©t√© de chemin, qui est le chemin URL de la route, et une propri√©t√© de composant qui d√©finit quel composant sera charg√© lorsque l'application acc√®de √† cette route. Notez que la valeur de la propri√©t√© path ne contient pas de /.

La navigation dans une application Angular 10 peut se produire soit en modifiant l'URL du navigateur, soit en demandant au routeur de naviguer le long d'un chemin d'itin√©raire dans le code de l'application. Dans le premier cas, lorsque l'URL du navigateur contient la route/ listes, le routeur cr√©e une instance de ListesComponent et affiche son mod√®le sur la page. Au contraire, lorsque l'application navigue vers /listes par code, le routeur suit la m√™me proc√©dure, et en plus, il met √† jour l'URL du navigateur.

Si l'utilisateur tente d'acc√©der √† une URL qui ne correspond √† aucune route, Angular active un type de route personnalis√© appel√© route g√©n√©rique. La route g√©n√©rique a une propri√©t√© de chemin avec deux ast√©risques et correspond √† n'importe quelle URL. La propri√©t√© du composant est g√©n√©ralement un PageNotFoundComponent sp√©cifique √† l'application ou le composant principal de l'application.

# point-5
### Rendu des composants
L'une des directives que la biblioth√®que de routeurs exporte √† l'aide de la m√©thode forRoot est router-outlet. Il est utilis√© comme composant angulaire et agit comme un espace r√©serv√© pour les composants activ√©s avec le routage.

En r√®gle g√©n√©rale, l'AppComponent d'une application Angular 10 est utilis√© uniquement pour fournir la disposition principale de l'application et orchestrer tous les autres composants. Nous devons l'√©crire une fois et l'oublier, et ne pas le modifier lorsque nous voulons ajouter une nouvelle fonctionnalit√© √† notre application. Ainsi, un exemple typique d'AppComponent est le suivant :

```html
<app-header></app-header>
<router-outlet></router-outlet>
<app-footer></app-footer>
```
app-header et app-footer sont des composants de mise en page, et router-outlet est l'endroit o√π tous les autres composants sont rendus √† l'aide du routage. En r√©alit√©, ces composants sont rendus comme un √©l√©ment fr√®re de la directive router-outlet.

Nous avons d√©j√† couvert les bases et fourni une configuration minimale du routeur. Dans la section suivante, nous examinerons un exemple plus r√©aliste et √©largirons davantage nos connaissances sur le module de routage et comment il peut nous aider.

***
# point-5
### Cr√©ation d'une application angulaire avec routage

```shell
Commande pour cr√©er une application avec le module routing
ng new application --routing --skipTests
```
Cela g√©n√®re √† peu pr√®s les m√™mes fichiers que d'habitude mais √† une exception pr√®s, le fichier app-routing.module.ts :

```typescript
import¬†{¬†NgModule¬†}¬†from¬†'@angular/core';
import¬†{¬†Routes,¬†RouterModule¬†}¬†from¬†'@angular/router';
const¬†routes:¬†Routes¬†=¬†[];
@NgModule({
¬†¬†imports:¬†[RouterModule.forRoot(routes)],
¬†¬†exports:¬†[RouterModule]
})
export¬†class¬†AppRoutingModule¬†{¬†}
```
Il s'agit d'un module angulaire utilis√© pour configurer et activer le routeur dans notre application. Il importe RouterModule en utilisant la m√©thode forRoot, comme nous l'avons d√©j√† appris dans la section pr√©c√©dente. Il r√©exporte √©galement RouterModule afin que les composants d'autres modules qui importent AppRoutingModule aient acc√®s aux services et directives du routeur. Par d√©faut, AppModule importe AppRoutingModule, donc tous les composants de notre application sont activ√©s avec des capacit√©s de routage :

```typescript
import¬†{¬†BrowserModule¬†}¬†from¬†'@angular/platform-browser';
import¬†{¬†NgModule¬†}¬†from¬†'@angular/core';
import¬†{¬†AppRoutingModule¬†}¬†from¬†'./app-routing.module';
import¬†{¬†AppComponent¬†}¬†from¬†'./app.component';
@NgModule({
¬†¬†declarations:¬†[
¬†¬†¬†¬†AppComponent
¬†¬†],
¬†¬†imports:¬†[
¬†¬†¬†¬†BrowserModule,
¬†¬†¬†¬†AppRoutingModule
¬†¬†],
¬†¬†providers:¬†[],
¬†¬†bootstrap:¬†[AppComponent]
})
export¬†class¬†AppModule¬†{¬†}
```
***
# point-7
### Ajout de la configuration de l'itin√©raire √† notre application Angular

Le module principal de notre application n'a pas encore de configuration d'itin√©raire. La variable routes dans AppRoutingModule est un tableau vide. Commen√ßons par le remplir de valeurs :

```html
Cr√©ez deux composants angulaires, un nomm√© user-list et un autre nomm√© user-detail.

Note importante :

>√âtant donn√© que ces composants vont √™tre activ√©s avec le routage, nous pouvons supprimer en toute s√©curit√© leur propri√©t√© selector du d√©corateur @Component. 

Cependant, il est utile de les laisser inchang√©s √† des fins de d√©bogage car nous pouvons identifier rapidement les composants plus tard dans l'arborescence DOM.

>Ajoutez deux objets de d√©finition d'itin√©raire dans la variable routes, un pour chaque composant. 
La route des users activera UserListComponent, et la route du user activera UserDetailComponent:
```

```typescript
const¬†routes:¬†Routes¬†=¬†[
¬†¬†{¬†path:¬†'users',¬†component:¬†UsersListComponent¬†},
¬†¬†{¬†path:¬†'user',¬†component:¬†UserDetailComponent¬†}
];
```
Maintenant que nous avons configur√© le routage de notre application, nous devons simplement apprendre √† naviguer vers une route sp√©cifique.

# point-8
### Navigation via les routes

Nous allons utiliser deux directives de routeur pour effectuer la navigation dans notre application, la directive router-outlet que nous avons d√©j√† vue et routerLink. Nous appliquons la directive routerLink pour ancrer les √©l√©ments HTML, et nous attribuons le chemin de route dans lequel nous voulons naviguer en tant que valeur. Notez que le chemin commence par / par opposition √† la propri√©t√© path dans l'objet de d√©finition d'itin√©raire. 
Commen√ßons :
* Ouvrez le fichier app.component.html et remplacez tout le contenu par une directive router-outlet.
* Ajoutez un √©l√©ment HTML de navigation contenant deux balises d'ancrage, une pour chaque composant.
* Ajoutez la directive routerLink √† chaque balise et attribuez les chemins respectifs √† partir de la configuration d'itin√©raire que nous avons cr√©√©e pr√©c√©demment :

```html
<nav>
¬†¬†<a¬†routerLink="/users">Users</a>
¬†¬†<a¬†routerLink="/user">User</a>
</nav>
<router-outlet></router-outlet>
```
Nous sommes maintenant pr√™ts √† pr√©visualiser notre application Angular. Ex√©cutez ng serve et cliquez sur le lien Users. L'application doit afficher le mod√®le de UsersListComponent sous l'√©l√©ment nav. Il doit √©galement mettre √† jour l'URL du navigateur pour qu'elle corresponde au chemin de l'itin√©raire. Maintenant, essayez de faire le contraire. Acc√©dez au chemin racine, http: // localhost: 4200, et ajoutez le chemin /users √† la fin de l'URL.

***
# point-8
### Modules de routage

√Ä ce stade, nous avons configur√© l'itin√©raire pour que le routage fonctionne comme il se doit. Cependant, cette approche ne s'adapte pas aussi bien. Au fur et √† mesure que notre application se d√©veloppe, de plus en plus de routes peuvent √™tre ajout√©es √† AppRoutingModule. Ainsi, nous devrions cr√©er un module de fonctionnalit√©s distinct pour nos composants qui aura √©galement un module de routage d√©di√©.

```bash
ng generate module users --routing
```
Le param√®tre --routing demande √† la CLI angulaire de cr√©er un module de routage avec le module de fonctionnalit√©s users :
* users-routing.module.ts
* users.module.ts

La CLI angulaire nomme le fichier du module de routage apr√®s le nom du module de fonctionnalit√©s r√©el, en ajoutant le suffixe -routing. Il s'agit d'une convention qui nous aide √† identifier rapidement si un module de fonctionnalit√©s a le routage activ√© et lequel est le module de routage du module de fonctionnalit√©s respectif. Le nom de la classe TypeScript du module de routage suit √©galement une convention similaire :

```typescript
import¬†{¬†NgModule¬†}¬†from¬†'@angular/core';
import¬†{¬†Routes,¬†RouterModule¬†}¬†from¬†'@angular/router';
const¬†routes:¬†Routes¬†=¬†[];
@NgModule({
¬†¬†imports:¬†[RouterModule.forChild(routes)],
¬†¬†exports:¬†[RouterModule]
})
export¬†class¬†UsersRoutingModule¬†{¬†}
```
Dans l'extrait de code pr√©c√©dent, vous avez peut-√™tre remarqu√© que nous n'importons pas RouterModule en utilisant la m√©thode forRoot comme nous l'avons fait auparavant. 

√Ä la place, nous utilisons la m√©thode forChild pour cela. La m√©thode forChild est utilis√©e lorsque nous voulons enregistrer des routes dans un module de fonctionnalit√©s. Vous ne devez appeler la m√©thode forRoot que dans le module de routage du module d'application principal, AppRoutingModule.

Maintenant que nous avons cr√©√© notre module de fonctionnalit√©s et le module de routage associ√©, nous devons d√©placer tous les artefacts li√©s aux fonctionnalit√©s d'AppModule vers UsersModule. Commencez par d√©placer les composants, puis proc√©dez √† la configuration de l'itin√©raire :

D√©placez les dossiers de la liste des users et des d√©tails des users dans le dossier des users.
Supprimez les d√©clarations UserListComponent et UserDetailComponent d'AppModule et ajoutez-les √† la propri√©t√© declarations de UsersModule. N'oubliez pas de d√©placer leurs instructions d'importation en haut du fichier.

Prenez le contenu de la variable routes dans le fichier app-routing.module.ts et d√©placez-le vers la propri√©t√© respective du fichier users-routing.module.ts. N'oubliez pas de d√©placer √† nouveau les instructions d'importation associ√©es. La configuration de la route d'AppRoutingModule doit maintenant √™tre un tableau vide.

Enfin, ajoutez UsersModule au-dessus de AppRoutingModule dans la propri√©t√© importations d'AppModule.


>Note importante
>L'ordre dans lequel nous importons les modules de routage est important. Le routeur s√©lectionne un itin√©raire avec une strat√©gie de premier match gagne. Nous pla√ßons des modules de routage de fonctionnalit√©s qui contiennent des routes plus sp√©cifiques avant le module de routage d'application principal qui contient des routes plus g√©n√©riques, telles qu'une route g√©n√©rique. Ainsi, nous voulons forcer le routeur √† rechercher d'abord dans nos chemins d'itin√©raire sp√©cifiques, puis √† revenir √† un chemin sp√©cifique √† l'application.

Si nous ex√©cutons maintenant l'application Angular en utilisant ng serve, nous verrons qu'elle fonctionne comme avant. Nous n'avons pas introduit de nouvelles fonctionnalit√©s ni fait quelque chose d'extraordinaire, mais nous avons ouvert la voie √† une s√©paration efficace de nos configurations d'itin√©raire. 

Le routeur combine les routes de notre module de fonctionnalit√©s, UsersModule, avec celles du module d'application principal, AppModule. Ainsi, nous pouvons continuer √† travailler avec le routage dans notre module de fonctionnalit√©s sans modifier la configuration de l'itin√©raire principal.

Actuellement, la configuration de l'itin√©raire de notre application est assez simple. Nous devons prendre en compte certains sc√©narios lors de l'utilisation du routage dans une application Web, tels que les suivants:

* Souhaitons-nous afficher une vue sp√©cifique lorsque nous d√©marrons notre application?
* Que va-t-il se passer si nous essayons de naviguer vers un chemin de route inexistant?

***
# point-9
### Gestion des routes inconnus 

Nous avons d√©j√† rencontr√© le concept de routes inconnues dans la section Pr√©sentation du routeur angulaire. Nous avons configur√© une route g√©n√©rique pour afficher un PageNotFoundComponent lorsque notre application essaie de naviguer vers un chemin de route qui n'existe pas. Il est maintenant temps d'ajouter ce composant :

1. Utilisez la CLI angulaire pour cr√©er un nouveau composant nomm√© page-not-found. Notre application affichera le composant nouvellement g√©n√©r√© lorsque nous naviguerons vers un chemin d'itin√©raire inconnu. Assurez-vous de lui donner un contenu significatif dans le mod√®le:
```html
<h3>Ooops!</h3>
<p>The¬†requested¬†page¬†was¬†not¬†found</p>
```
2. Ouvrez le fichier app-routing.module.ts et ajoutez un nouvel objet de d√©finition d'itin√©raire dans la variable routes. D√©finissez la propri√©t√© path sur les doubles ast√©risques et la propri√©t√© du composant sur le nouveau composant que vous avez cr√©√©:

```typescript
const¬†routes:¬†Routes¬†=¬†[
¬†¬†{¬†path:¬†'**',¬†component:¬†PageNotFoundComponent¬†}
];
```
>Note importante
>Il est pr√©f√©rable de d√©finir une route g√©n√©rique avec le composant associ√© dans AppRoutingModule. La route g√©n√©rique s'applique √† l'ensemble de l'application et n'est donc pas li√©e √† une fonctionnalit√© sp√©cifique.

Si nous ex√©cutons ng serve et orientons le navigateur vers http://localhost:4200/ angular, nous voyons que le composant page introuvable est affich√© √† l'√©cran car notre application n'a pas de route angulaire.

>Note importante
>Lorsque le routeur rencontre une route inconnue, il navigue vers la route g√©n√©rique, mais le navigateur pointe toujours vers l'URL non valide.

Essayez de naviguer vers le chemin racine de notre application, http://localhost:4200, et vous remarquerez que le composant de page introuvable est toujours visible √† l'√©cran. Nous avons accidentellement cass√© notre application! Pourquoi est-ce arriv√©?

L'attribut href de la balise de base est l'emplacement auquel une application Angular d√©marre, comme nous l'avons appris dans la section Pr√©sentation du routeur angulaire. La CLI Angular d√©finit la valeur de href sur / par d√©faut lors de la cr√©ation d'une nouvelle application Angular. 

Nous avons √©galement appris qu'une route ne contient pas / dans sa propri√©t√© path. Ainsi, lorsque notre application d√©marre, elle se charge dans le '' chemin de route vide. 

Selon nos configurations d'itin√©raire, nous n'avons pas d√©fini un tel chemin. Ainsi, le routeur revient sur la route g√©n√©rique et affiche le composant de page non trouv√©e √† l'√©cran.

Nous devons d√©finir une route par d√©faut pour notre application Angular, ce qui nous am√®ne au premier sc√©nario que nous avons d√©crit: comment d√©finir un chemin de route par d√©faut lorsque notre application d√©marre.

*** 
# point-10
### Configurer la route par d√©faut

Nous d√©finissons la propri√©t√© path d'une route sur une cha√Æne vide pour indiquer que la route est celle par d√©faut pour une application Angular. Dans notre cas, nous voulons que le chemin de route par d√©faut affiche UsersListComponent:

1. Ouvrez le fichier users-routing.module.ts et ajoutez un nouvel objet de d√©finition d'itin√©raire sous les itin√©raires existants.
2. D√©finissez la propri√©t√© path sur une cha√Æne vide, ¬´¬ª, et la propri√©t√© du composant sur UserListComponent.
3. Ex√©cutez l'application, et vous remarquerez que lorsque l'URL du navigateur pointe vers le chemin racine de notre application, le composant de la liste des users s'affiche √† l'√©cran.

Cependant, nous aurions pu faire mieux que de d√©finir un nouveau chemin de route pour UserListComponent. 

Introduisons un autre terme de routage, rediriger. Remplacez l'objet de d√©finition d'itin√©raire par d√©faut par ce qui suit:
```javascript
{¬†path:¬†'',¬†redirectTo:¬†'/users',¬†pathMatch:¬†'full'¬†}
```
Nous disons au routeur de rediriger vers le chemin /users lorsque l'application navigue vers la route par d√©faut. La propri√©t√© pathMatch indique au routeur comment faire correspondre l'URL √† la propri√©t√© du chemin d'itin√©raire. Dans ce cas, le routeur redirige vers le chemin /users uniquement lorsque l'URL correspond √† la route par d√©faut.

Il est √† noter que nous avons ajout√© le chemin de route vide apr√®s toutes les autres routes car, comme nous l'avons d√©j√† appris, l'ordre des routes est important. Nous voulons des itin√©raires plus sp√©cifiques avant des itin√©raires moins sp√©cifiques. Dans le diagramme suivant, vous pouvez voir l'ordre dans lequel le routeur r√©sout les chemins dans notre application:

![](routeur3.jfif)

Nous avons d√©j√† appris √† naviguer dans notre application √† l'aide de la directive routerLink. C'est la m√©thode pr√©f√©r√©e lors de l'utilisation d'√©l√©ments d'ancrage dans un mod√®le. Cependant, dans une application du monde r√©el, nous utilisons √©galement des boutons pour la navigation. Dans la section suivante, nous allons apprendre √† naviguer vers un chemin d'itin√©raire imp√©rativement √† l'aide d'un √©l√©ment bouton.

# point-11
### Naviguer imp√©rativement vers un itin√©raire

Lorsque nous naviguons vers une route g√©n√©rique, le mod√®le de la propri√©t√© du composant est affich√© √† l'√©cran. Cependant, comme nous l'avons vu, la barre d'adresse du navigateur reste sur l'URL invalide. Nous devons donc fournir un moyen pour l'utilisateur de s'√©chapper de cette route:

1. Ouvrez le fichier page-not-found.component.html et ajoutez un √©l√©ment HTML de bouton.
2. Ajoutez une liaison d'√©v√©nement √† l'√©v√©nement DOM de clic natif de l'√©l√©ment bouton. D√©finissez l'instruction de mod√®le de la liaison sur une m√©thode de composant goHome, qui n'existe pas encore. 

```html
<button¬†(click)="goHome()">Home</button>
```
3. Ouvrez le fichier page-not-found.component.ts et cr√©ez la m√©thode goHome.
4. RouterModule exporte le service Router que nous pouvons utiliser dans nos composants pour effectuer une navigation imp√©rative, dans le code. Injectez le service dans le constructeur de PageNotFoundComponent.
5. Appelez la m√©thode de navigation du service Router dans la m√©thode goHome pour naviguer dans le chemin racine de l'application. Il accepte un tableau de param√®tres de lien qui contient deux √©l√©ments - le chemin de route de destination et tous les param√®tres de route, comme nous l'apprendrons plus tard dans le chapitre:

```typescript
import¬†{¬†Component¬†}¬†from¬†'@angular/core';
import¬†{¬†Router¬†}¬†from¬†'@angular/router';
@Component({
¬†¬†selector:¬†'app-page-not-found',
¬†¬†templateUrl:¬†'./page-not-found.component.html',
¬†¬†styleUrls:¬†['./page-not-found.component.css']
})
export¬†class¬†PageNotFoundComponent¬†{
¬†¬†constructor(private¬†router:¬†Router)¬†{¬†}
¬†¬†goHome()¬†{
¬†¬†¬†¬†this.router.navigate(['/']);
¬†¬†}
}
```
Il convient de noter que le tableau des param√®tres de liaison peut √©galement √™tre utilis√© dans la directive routerLink. Par exemple, nous aurions pu √©crire l'√©l√©ment d'ancrage de la route des h√©ros comme suit:
```html
<a¬†[routerLink]="['/users']">Users</a>
```
>Remarque importante
>Nous pourrions utiliser la navigation imp√©rative avec un √©l√©ment d'ancrage, ainsi qu'une directive routerLink avec un √©l√©ment bouton. C'est parfaitement bien. Cependant, il est plus s√©mantiquement correct de les utiliser comme sugg√©r√© dans ce livre. La directive routerLink modifie le comportement de l'√©l√©ment cible et ajoute un attribut href, qui cible les √©l√©ments d'ancrage.

Jusqu'√† pr√©sent, nous nous sommes appuy√©s sur la barre d'adresse du navigateur pour indiquer quel chemin d'itin√©raire est actif √† un moment donn√©. Nous pourrions am√©liorer l'exp√©rience utilisateur en utilisant le style CSS pour ce faire.

***
# point-12
### D√©corer les liens de routeur avec style

RouterModule exporte la directive routerLinkActive, que nous pouvons utiliser pour changer le style d'une route active. Cela fonctionne de mani√®re similaire √† la liaison de classe que nous avons apprise au chapitre 3, Interaction des composants et inter-communication. Il accepte une liste de noms de classe ou une seule classe qui est ajout√©e lorsque le lien est actif et est supprim√©e lorsqu'elle est inactive:

1. Ouvrez le fichier app.component.css et d√©finissez une classe active qui d√©finit la couleur d'arri√®re-plan sur une valeur de votre choix:
```css
.active¬†{
¬†¬†background-color:¬†lightgray;
}
```

2. Ajoutez la directive routerLinkActive aux deux liens dans app.component.html et d√©finissez-la sur le nom de la classe active:

```html
<a¬†routerLink="/users"¬†routerLinkActive="active">Users</a>
<a¬†routerLink="/user"¬†routerLinkActive="active">user</a>
```

D√©sormais, lorsque nous cliquons sur un lien dans notre application, sa couleur d'arri√®re-plan devient la couleur que nous avons choisie.

Nous avons d√©j√† appris que nous pouvons naviguer vers une route avec une valeur de chemin statique. Dans le point suivant, nous apprendrons comment faire cela lorsque le chemin change en passant dynamiquement les param√®tres d'itin√©raire.

***
# point-13
### Passer des param√®tres aux routes

Un sc√©nario courant dans les applications Web est d'avoir une liste d'√©l√©ments, et lorsque vous cliquez sur l'un d'entre eux, la page change la vue actuelle et affiche les d√©tails de l'√©l√©ment s√©lectionn√©. Cela ressemble √† une fonctionnalit√© de navigation ma√Ætre-d√©tails, o√π chaque URL g√©n√©r√©e vivant dans la page ma√Ætre contient les identifiants requis pour charger chaque √©l√©ment dans la page de d√©tails.

Nous pouvons repr√©senter le sc√©nario pr√©c√©dent avec deux routes qui naviguent vers diff√©rents composants. Un composant est la liste des √©l√©ments et l'autre est les d√©tails d'un √©l√©ment. Nous devons donc trouver un moyen de cr√©er et de transmettre des donn√©es dynamiques sp√©cifiques aux √©l√©ments d'une route √† l'autre.

Nous nous attaquons ici √† un double probl√®me: cr√©er des URL avec des param√®tres dynamiques lors de l'ex√©cution et analyser la valeur de ces param√®tres. Pas de probl√®me: le routeur Angular nous soutient, et nous verrons comment utiliser un exemple r√©el.

***
# point-14
### Cr√©ation d'une page de d√©tail √† l'aide des param√®tres d'itin√©raire

Nous devons refactoriser le projet Angular CLI sur lequel nous travaillons afin de reproduire le sc√©nario pr√©c√©dent. Le flux de notre application doit √™tre le suivant:

1. UsersListComponent affiche une liste de users √† partir d'une API backend.
2. L'utilisateur clique sur un user de la liste.
3. L'application redirige l'utilisateur vers le composant UserDetailComponent, qui est charg√© de r√©cup√©rer les d√©tails du user s√©lectionn√© √† partir de l'API backend.

*** 
1. Ouvrez le fichier users-routing.module.ts et ajoutez le suffixe /:id √† la propri√©t√© path de la route user:
```typescript
{¬†path:¬†'user/:id',¬†component:¬†UserDetailComponent¬†}
```
Le caract√®re deux-points indique que id est un param√®tre d'itin√©raire. Si une route a plus d'un param√®tre, nous les s√©parons par /. Le nom du param√®tre, id, est important lorsque nous voulons consommer sa valeur dans nos composants, comme nous l'apprendrons plus tard.

2. Ouvrez le fichier user-list.component.html et convertissez chaque √©l√©ment de paragraphe en un √©l√©ment d'ancrage qui affiche la propri√©t√© name d'un user. Ajoutez la directive routerLink √† chaque √©l√©ment d'ancrage et utilisez la liaison de propri√©t√© pour d√©finir sa valeur dans un tableau de param√®tres de lien. D√©finissez le deuxi√®me √©l√©ment du tableau sur la propri√©t√© id de la variable de r√©f√©rence du mod√®le de users:

```html
<a¬†[routerLink]="['/user',¬†user.id]">{{user.name}}</a>
```

La directive routerLink requiert une liaison de propri√©t√© lors du traitement des routes dynamiques. Il cr√©era un attribut href contenant le chemin 
/user, suivi de la valeur de sa propri√©t√© id.

Si nous ex√©cutons l'application et cliquons sur le nom d'un h√©ros, cela ne fait rien de plus que de naviguer vers UserDetailComponent comme auparavant. Nous n'avons pas encore profit√© du nouveau param√®tre d'itin√©raire de l'itin√©raire users.

UserDetailComponent doit obtenir la valeur du param√®tre id et faire une requ√™te HTTP √† l'API backend pour r√©cup√©rer le user avec cet identifiant particulier. Enfin, il convient de d√©finir le user retourn√© dans une propri√©t√© de composant afin que nous puissions afficher ses d√©tails dans le mod√®le du composant:

1. Supprimez l'√©l√©ment d'ancrage qui pointe vers l'itin√©raire du h√©ros du mod√®le d'AppComponent.
2. Ajoutez une m√©thode getUser √† UserService qui utilise le client HTTP pour obtenir des d√©tails sur un h√©ros particulier. La m√©thode doit renvoyer un Observable de type User:

```typescript
getUser(id:¬†number):¬†Observable<User>¬†{
¬†¬†return¬†this.http.get<User>(this.usersUrl¬†+¬†id);
}
```
3. RouterModule exporte le service ActivatedRoute, que nous pouvons utiliser pour r√©cup√©rer des informations sur la route actuellement active, y compris tous les param√®tres. Injectez le service ActivatedRoute dans le constructeur de UserDetailComponent:

```typescript
constructor(private¬†route:¬†ActivatedRoute)¬†{¬†}
```
4. Cr√©ez une propri√©t√© user dans le composant et utilisez l'interpolation pour afficher sa propri√©t√© name dans le mod√®le du composant:

```html
<p>{{user?.name}}¬†works!</p>
```

Le caract√®re ? que nous avons ajout√© √† la propri√©t√© user est appel√© un op√©rateur de navigation s√©curis√©. Il est utilis√© pour prot√©ger notre composant contre les valeurs nulles ou non d√©finies de la propri√©t√© user. 

Si nous n'utilisons pas cet op√©rateur, le retard que nous subissons √† cause de la requ√™te HTTP cassera notre mod√®le. Le mod√®le essaiera d'afficher la propri√©t√© name d'un objet user qui n'a pas encore √©t√© d√©fini et g√©n√©rera une erreur. Alternativement, nous aurions pu utiliser la directive ngIf dans l'√©l√©ment de paragraphe pour √©viter ce type d'erreur.

Le service ActivatedRoute contient l'observable paramMap, que nous pouvons souscrire pour obtenir les valeurs des param√®tres d'itin√©raire. UserDetailComponent a besoin d'obtenir la valeur du param√®tre id de l'observable paramMap et de faire un appel √† la m√©thode getUser de UserService, qui est √©galement une observable. Alors, comment pouvons-nous accomplir cette t√¢che?

Nous introduisons un autre op√©rateur RxJS, switchMap, pour passer d'une observable √† l'autre. Nous profitons √©galement de l'op√©rateur de carte pour d√©finir le user renvoy√© par l'API backend sur la propri√©t√© du composant de user local:

```typescript
ngOnInit():¬†void¬†{
¬†¬†this.getUserObs();
}
private¬†getUserObs()¬†{
¬†¬†this.route.paramMap.pipe(
¬†¬†¬†¬†switchMap((params:¬†ParamMap)¬†=>¬†{
¬†¬†¬†¬†¬†¬†const¬†id¬†=¬†+params.get('id');
¬†¬†¬†¬†¬†¬†return¬†this.userService.getUser(id);
¬†¬†¬†¬†}),
¬†¬†¬†¬†map(user=>¬†this.user=¬†user)
¬†¬†).subscribe();
}
```

L'avantage de l'utilisation de l'op√©rateur switchMap est qu'il peut annuler toutes les requ√™tes HTTP en attente. Autrement dit, si l'utilisateur renoue avec le m√™me chemin de route avec un identifiant diff√©rent et que la requ√™te HTTP pr√©c√©dente n'est pas encore termin√©e, il rejette l'ancienne requ√™te et poursuit avec la nouvelle.

Dans l'extrait de code pr√©c√©dent, il convient de noter ce qui suit:

* L'observable paramMap renvoie un objet de type ParamMap. Nous pouvons utiliser la m√©thode get de l'objet ParamMap et passer le nom du param√®tre que nous avons d√©fini dans la configuration de l'itin√©raire pour acc√©der √† sa valeur.

* Nous ajoutons le signe plus devant le param√®tre id pour le convertir d'une cha√Æne en un nombre.

Ex√©cutez l'application en utilisant ng serve et cliquez sur le nom d'un user dans la liste. L'application acc√®de √† UserDetailComponent et affiche le nom du User s√©lectionn√©. Nous avons int√©gr√© avec succ√®s le routage et HTTP dans notre application Angular 10. Impressionnant!

Dans l'exemple pr√©c√©dent, nous avons utilis√© paramMap pour obtenir les param√®tres d'itin√©raire sous forme d'observable. Ainsi, id√©alement, notre composant pourrait √™tre notifi√© avec de nouvelles valeurs pendant sa dur√©e de vie. Mais le composant est d√©truit √† chaque fois que nous voulons s√©lectionner un user diff√©rent dans la liste, tout comme l'abonnement √† l'observable paramMap. Alors, quel est l'int√©r√™t de l'utiliser apr√®s tout?

Le routeur peut r√©utiliser l'instance d'un composant d√®s qu'elle reste rendue √† l'√©cran lors de navigations cons√©cutives. Nous pouvons r√©aliser ce comportement en utilisant des routes enfants.
***
# point-15
### R√©utilisation de composants √† l'aide d'itin√©raires enfants

Nous utilisons des routes enfants lorsque nous voulons d√©finir un composant de conteneur pour un module de fonctionnalit√© qui agira en tant qu'orchestrateur de routage pour les composants de ce module. Il contient un √©l√©ment de sortie de routeur dans lequel les routes enfants seront charg√©es. Supposons que nous voulions d√©finir la disposition de notre application Angular comme suit:

![](routeur4.jfif)

UserListComponent doit contenir le contenu existant avec un √©l√©ment de sortie de routeur. L'√©l√©ment suppl√©mentaire router-outlet est utilis√© pour rendre UserDetailComponent lorsque la route associ√©e est activ√©e.

>Note importante
>Le mod√®le de UserDetailComponent est rendu dans l'√©l√©ment router-outlet de UserListComponent et non dans l'√©l√©ment router-outlet d'AppComponent.

UserDetailComponent n'est pas d√©truit lorsque nous naviguons d'un user √† un autre. Au lieu de cela, il reste dans l'arborescence DOM et la m√©thode ngOnInit est appel√©e une fois, la premi√®re fois que nous s√©lectionnons un user. Lorsque nous s√©lectionnons un nouveau h√©ros dans la liste, l'observable paramMap √©met l'identifiant du nouveau h√©ros. UserService r√©cup√®re le h√©ros demand√© et le mod√®le du composant est actualis√© pour refl√©ter les nouvelles modifications.

La configuration de l'itin√©raire de notre application Angular, dans ce cas, serait la suivante:

```typescript
const¬†routes:¬†Routes¬†=¬†[
¬†¬†{
¬†¬†¬†¬†path:¬†'users',
¬†¬†¬†¬†component:¬†UserListComponent,
¬†¬†¬†¬†children:¬†[
¬†¬†¬†¬†¬†¬†{¬†path:¬†':id',¬†component:¬†UserDetailComponent¬†},
¬†¬†¬†¬†]
¬†¬†},
¬†¬†{¬†path:¬†'',¬†redirectTo:¬†'/users',¬†pathMatch:¬†'full'¬†}
];
```

Nous utilisons la propri√©t√© children d'un objet de configuration d'itin√©raire pour d√©finir des itin√©raires enfants, qui contient une liste d'objets de configuration d'itin√©raire. Notez √©galement que nous avons supprim√© le mot user de la propri√©t√© path de la route user. Nous voulions pr√©ciser qu'il s'agit d'un enfant de la route des users, et qu'il doit √™tre accessible en utilisant le chemin /users/:id.

Nous devons √©galement changer la directive routerLink des √©l√©ments d'ancrage dans le fichier user-list.component.html afin que notre application fonctionne correctement:

```html
<a¬†[routerLink]="['./',¬†user.id]">{{user.name}}</a>
```

Notez que nous avons remplac√© /user par ./ . Quelle est cette √©trange syntaxe? 
Elle est appel√©e navigation relative et indique au routeur de naviguer vers une route sp√©cifique par rapport √† la route actuellement activ√©e. 
C'est le contraire de la syntaxe actuelle que nous avons utilis√©e jusqu'√† pr√©sent, qui est appel√©e navigation absolue. 

Par exemple, le chemin ./ indique de naviguer par rapport au niveau actuel, qui est /users, dans notre cas. Si la route vers laquelle nous voulions naviguer √©tait un niveau au-dessus de la route des h√©ros, nous aurions utilis√© ../ comme chemin. Vous pouvez y voir une navigation entre les dossiers en utilisant la ligne de commande. La m√™me syntaxe s'applique √©galement √† la navigation imp√©rative:

```typescript
this.router.navigate(['./', user.id], { relativeTo: this.route });
```
Dans ce cas, nous passons un objet NavigationExtras suppl√©mentaire apr√®s le tableau de param√®tres de lien qui d√©finit la propri√©t√© relativeTo qui pointe vers la route actuellement activ√©e.

>Note importante
>La navigation relative est consid√©r√©e comme un meilleur choix par rapport √† la navigation absolue car elle est plus facile √† refactoriser. Il d√©couple les liens cod√©s en dur en d√©finissant des chemins par rapport √† l'itin√©raire actuel. Imaginez d√©placer un tas de composants et soudainement tous vos chemins cod√©s en dur sont faux. La navigation √† l'int√©rieur d'un module d'entit√©s fonctionne comme pr√©vu, m√™me si vous d√©cidez de modifier l'itin√©raire parent.

Nous avons appris comment tirer parti de l'observable paramMap dans le routage angulaire. Cela n'apporte clairement aucun avantage √† notre application Angular. Dans la section suivante, nous discuterons d'une approche alternative utilisant des instantan√©s d'itin√©raire.
***
# point-16
### Prendre un instantan√© (snapshot) des param√®tres de routage

Actuellement, lorsque nous s√©lectionnons un user dans la liste, UserListComponent est supprim√© de l'arborescence DOM et UserDetailComponent est ajout√©. Pour s√©lectionner un autre user, nous cliquons sur le lien Users ou sur le bouton Pr√©c√©dent de notre navigateur. Par cons√©quent, UserDetailComponent est supprim√© du DOM et UserListComponent est ajout√©. Nous sommes donc dans une situation o√π un seul composant est affich√© √† l'√©cran √† la fois.

Lorsque UserDetailComponent est d√©truit, la m√©thode ngOnInit et l'abonnement √† l'observable paramMap le sont √©galement. Ainsi, nous ne tirons aucun avantage en utilisant des observables √† ce stade. Alternativement, nous pourrions utiliser la propri√©t√© snapshot du service ActivatedRoute pour obtenir des valeurs pour les param√®tres d'itin√©raire:

```typescript
private¬†getUserSnap()¬†{
¬†¬†const¬†id¬†=¬†this.route.snapshot.params['id'];
¬†¬†this.userService.getUser(id).subscribe(user =>¬†this.user¬†=¬†user);
}
```

La propri√©t√© snapshot contient toujours la valeur actuelle d'un param√®tre d'itin√©raire, qui se trouve √™tre √©galement la valeur initiale. Il contient la propri√©t√© params, qui est un objet de type Params. Un objet Params contient des paires cl√©-valeur de param√®tre d'itin√©raire, auxquelles nous pouvons acc√©der comme nous le ferions pour un objet standard dans TypeScript.

>Note importante
>Si vous √™tes s√ªr que votre composant ne sera pas r√©utilis√©, vous devriez opter pour l'approche snapshot car elle est √©galement plus lisible.

Jusqu'√† pr√©sent, nous avons trait√© des param√®tres de routage sous la forme users/:id. Nous utilisons ces types de param√®tres lorsque nous voulons acheminer vers un composant qui n√©cessite que le param√®tre fonctionne correctement. Dans notre cas, UserDetailComponent a besoin du param√®tre id pour pouvoir obtenir les d√©tails d'un h√©ros sp√©cifique. Cependant, il existe un autre type de param√®tre consid√©r√© comme facultatif, comme nous l'apprendrons dans la section suivante.

***
# point-17
### Filtrage des donn√©es √† l'aide des param√®tres de requ√™te

Les param√®tres de requ√™te sont consid√©r√©s comme des param√®tres facultatifs car ils visent √† trier les donn√©es ou √† r√©duire la taille d'un ensemble de donn√©es. Quelques exemples sont les suivants:

* /users?sortOrder=asc: Trie une liste de users par ordre croissant
* /users?page=3&pageSize=10: Divise une liste des users en pages de 10 enregistrements et obtient la troisi√®me page

Les param√®tres de requ√™te sont reconnus dans une route par le caract√®re ? . Nous pouvons combiner plusieurs param√®tres de requ√™te en les cha√Ænant avec un caract√®re esperluette (&). 
Le service ActivatedRoute contient une observable queryParamMap que nous pouvons souscrire pour obtenir les valeurs des param√®tres de requ√™te. Il renvoie un objet ParamMap, similaire √† l'observable paramMap, que nous pouvons interroger pour obtenir les valeurs des param√®tres. Par exemple, pour r√©cup√©rer la valeur d'un param√®tre de requ√™te sortOrder, nous l'utiliserons comme suit:

```java
constructor(private¬†route:¬†ActivatedRoute)¬†{¬†}
ngOnInit():¬†void¬†{
¬†¬†this.route.queryParamMap.subscribe(params¬†=>¬†{
¬†¬†¬†¬†console.log(params.get('sortOrder'));
¬†¬†});
}
```

Une propri√©t√© queryParamMap est √©galement disponible lorsque vous travaillez avec le routage des instantan√©s pour obtenir les valeurs des param√®tres de requ√™te.

***
# point-18
### Contr√¥le de l'acc√®s √† une route
Lorsque nous voulons emp√™cher l'acc√®s non autoris√© √† une route particuli√®re, nous utilisons un service Angular sp√©cifique appel√© garde. Pour cr√©er une garde, nous utilisons la commande generate de la CLI angulaire, en passant le mot guard et son nom comme param√®tres:

```java
ng generate guard auth
```
Il existe plusieurs types de protecteurs que nous pouvons cr√©er en fonction des fonctionnalit√©s qu'ils fournissent. Chaque garde impl√©mente une interface diff√©rente:

* CanActivate: contr√¥le si une route peut √™tre activ√©.
* CanActivateChild: contr√¥le l'acc√®s aux routes enfants d'un itin√©raire.
* CanDeactivate: contr√¥le si une routepeut √™tre d√©sactiv√©. La d√©sactivation se produit lorsque nous nous √©loignons d'un itin√©raire.
* CanLoad: contr√¥le l'acc√®s √† une route qui charge un module charg√© paresseusement.

la valeur par d√©faut est CanActivate

```typescript
import¬†{¬†Injectable¬†}¬†from¬†'@angular/core';
import¬†{¬†CanActivate,¬†ActivatedRouteSnapshot,¬†RouterStateSnapshot,¬†UrlTree¬†}¬†from¬†'@angular/router';
import¬†{¬†Observable¬†}¬†from¬†'rxjs';
@Injectable({
¬†¬†providedIn:¬†'root'
})
export¬†class¬†AuthGuard¬†implements¬†CanActivate¬†{
¬†¬†canActivate(
¬†¬†¬†¬†next:¬†ActivatedRouteSnapshot,
¬†¬†¬†¬†state:¬†RouterStateSnapshot):¬†Observable<boolean¬†|¬†¬†¬†¬†¬†UrlTree>¬†|¬†Promise<boolean¬†|¬†¬†¬†¬†¬†UrlTree>¬†|¬†boolean¬†|¬†UrlTree¬†{
¬†¬†¬†¬†return¬†true;
¬†¬†}
¬†¬†
}
```
Le garde que nous avons cr√©√© impl√©mente la m√©thode canActivate de l'interface CanActivate, qui accepte deux param√®tres: 
* un objet ActivatedRouteSnapshot qui indique la route qui sera activ√©e et 
* RouterStateSnapshot, qui contient l'√©tat du routeur lors d'une navigation r√©ussie. 

La m√©thode canActivate peut renvoyer une valeur bool√©enne, de mani√®re synchrone ou asynchrone. Dans ce dernier cas, le routeur attendra que l'observable ou la promesse se r√©sout avant de continuer. Si l'√©v√©nement asynchrone ne se termine pas, la navigation ne continuera pas. 

La m√©thode canActivate peut √©galement renvoyer un objet UrlTree, ce qui entra√Ænera une nouvelle navigation vers un itin√©raire d√©fini.

Actuellement, notre garde revient imm√©diatement vrai, permettant un acc√®s gratuit √† un itin√©raire. Cr√©ons une propri√©t√© isAuthenticated afin de pouvoir modifier plus facilement le comportement de notre garde:

>Note importante
>Dans une application du monde r√©el, nous d√©l√©guerions la d√©cision d'authentifier ou non un utilisateur √† un service Angular s√©par√©. Le service v√©rifierait probablement le stockage local du navigateur ou tout autre moyen pour indiquer si l'utilisateur s'est d√©j√† authentifi√© ou non.

```typescript
export¬†class¬†AuthGuard¬†implements¬†CanActivate¬†{
¬†¬†private¬†isAuthenticated¬†=¬†true;
¬†¬†constructor(private¬†router:¬†Router)¬†{}
¬†¬†canActivate(
¬†¬†¬†¬†next:¬†ActivatedRouteSnapshot,
¬†¬†¬†¬†state:¬†RouterStateSnapshot):¬†Observable<boolean¬†|¬†UrlTree>¬†¬†¬†¬†¬†|¬†Promise<boolean¬†|¬†UrlTree>¬†|¬†boolean¬†|¬†UrlTree¬†{
¬†¬†¬†¬†return¬†this.checkLogin();
¬†¬†}
¬†¬†private¬†checkLogin():¬†boolean¬†{
¬†¬†¬†¬†if¬†(this.isAuthenticated)¬†{¬†return¬†true¬†};
¬†¬†¬†¬†this.router.navigate(['/']);
¬†¬†¬†¬†return¬†false;
¬†¬†}
}
```

Nous avons cr√©√© une m√©thode checkLogin distincte qui g√®re la logique d'autoriser ou non l'acc√®s √† l'itin√©raire. 

La m√©thode canActivate appelle la m√©thode checkLogin et renvoie sa valeur. Il v√©rifie la valeur de la propri√©t√© isAuthenticated, et si elle est vraie, l'application peut acc√©der √† l'itin√©raire sp√©cifi√©. 

Sinon, il utilise le service Router pour acc√©der au chemin racine de l'application Angular et renvoie false afin que la navigation pr√©c√©dente puisse √™tre annul√©e.

>Note importante
>Lorsque nous effectuons une redirection vers une autre route √† l'int√©rieur d'un garde, nous devons renvoyer une valeur fausse de la m√©thode canActivate afin que la navigation en cours puisse √™tre annul√©e.

Un objet de configuration d'itin√©raire contient la propri√©t√© canActivate, que nous pouvons utiliser pour appliquer une garde CanActivate √† une route sp√©cifique:

```typescript
const¬†routes:¬†Routes¬†=¬†[
¬†¬†{¬†path:¬†'users',¬†component:¬†UserListComponent¬†},
¬†¬†{¬†path:¬†'user/:id',¬†component:¬†UserDetailComponent,¬†¬†¬†canActivate:¬†[AuthGuard]¬†},
¬†¬†{¬†path:¬†'',¬†redirectTo:¬†'/users',¬†pathMatch:¬†'full'¬†}
];
```
Seuls les utilisateurs authentifi√©s peuvent d√©sormais acc√©der √† la route des h√©ros. Ex√©cutez l'application et inspectez le r√©sultat en utilisant diff√©rentes valeurs pour la propri√©t√© isAuthenticated d'AuthGuard.
 ***
# point-19
### Emp√™cher la navigation loin d'une route

De m√™me, pour emp√™cher l'acc√®s √† une route, nous pouvons √©galement emp√™cher la navigation loin d'une route √† l'aide de l'interface CanDeactivate <T>. T indique la classe de composant √† partir de laquelle nous voulons sortir. Nous devons impl√©menter la m√©thode canDeactivate dans un guard pour commencer √† l'utiliser:

1. Utilisez la CLI angulaire pour cr√©er une nouvelle garde nomm√©e confirm.
2. S√©lectionnez uniquement l'option CanDeactivate √† impl√©menter √† la demande de la CLI angulaire.
3. Ouvrez le fichier confirm.guard.ts et d√©finissez le type de l'interface CanDeactivate sur UserDetailComponent, car nous voulons v√©rifier si l'utilisateur s'√©loigne de ce composant uniquement. Dans un sc√©nario r√©el, vous devrez peut-√™tre cr√©er une protection plus g√©n√©rique pour prendre en charge des composants suppl√©mentaires:

```typescript
export¬†class¬†ConfirmGuard¬†implements¬†CanActivate,¬†CanDeactivate<UserDetailComponent>¬†{
}
```
4. D√©finissez √©galement le type du param√®tre de composant de la m√©thode canDeactivate sur UserDetailComponent.
5. Cr√©ez une m√©thode showConfirm qui utilise la m√©thode confirm de l'objet de fen√™tre globale pour afficher une bo√Æte de dialogue de confirmation avant de quitter UserDetailComponent. Assurez-vous que la m√©thode renvoie une observable avec une valeur bool√©enne:

```typescript
private¬†showConfirm():¬†Observable<boolean>¬†{
¬†¬†const¬†confirmation¬†=¬†window.confirm('Are¬†you¬†sure?');
¬†¬†return¬†of(confirmation);
}
```

6. La m√©thode canDeactivate peut renvoyer une valeur bool√©enne ou UrlTree de mani√®re synchrone ou asynchrone, similaire √† la m√©thode canActivate. Appelez la m√©thode showConfirm dans la m√©thode canDeactivate:

```typescript
canDeactivate(
¬†¬†component:¬†UserDetailComponent,
¬†¬†currentRoute:¬†ActivatedRouteSnapshot,
¬†¬†currentState:¬†RouterStateSnapshot,
¬†¬†nextState?:¬†RouterStateSnapshot):¬†Observable<boolean¬†|¬†¬†¬†UrlTree>¬†|¬†Promise<boolean¬†|¬†UrlTree>¬†|¬†boolean¬†|¬†¬†¬†UrlTree¬†{
¬†¬†return¬†this.showConfirm();
}
```

Un objet de configuration d'itin√©raire contient une propri√©t√© canDeactivate similaire √† canActivate. Ouvrez le fichier users-routing.module.ts et configurez-le en cons√©quence pour utiliser ConfirmGuard:

```typescript
{
¬†¬†path:¬†'user/:id',
¬†¬†component:¬†UserDetailComponent,
¬†¬†canActivate:¬†[AuthGuard],
¬†¬†canDeactivate:¬†[ConfirmGuard]
}
```
***
# point-20
### Pr√©chargement des donn√©es d'une route

Vous avez peut-√™tre remarqu√© que lorsque vous s√©lectionnez un user dans la liste et acc√©dez √† UserDetailComponent, il y a un d√©lai dans l'affichage des d√©tails du user. Ceci est raisonnable car nous faisons une requ√™te HTTP √† l'API backend. 

Cependant, il y a un scintillement dans l'interface utilisateur, ce qui est mauvais pour l'exp√©rience utilisateur. Heureusement, le routeur angulaire peut nous aider √† r√©soudre ce probl√®me. Nous pouvons utiliser un r√©solveur pour pr√©-r√©cup√©rer les d√©tails d'un user afin qu'ils soient disponibles lors de l'activation de la route et de l'affichage du composant.

>Note importante
>Un r√©solveur peut √™tre pratique lorsque nous voulons g√©rer d'√©ventuelles erreurs avant d'activer une route. Il serait plus appropri√© de ne pas naviguer vers UserDetailComponent si l'id que nous passons en tant que param√®tre d'itin√©raire n'existe pas dans le backend.

Un r√©solveur est un service angulaire qui impl√©mente l'interface Resolve <T>, o√π T est le type de donn√©es qui est r√©solu. Le service doit impl√©menter explicitement la m√©thode de r√©solution de cette interface. Il renvoie les donn√©es r√©solues de mani√®re synchrone ou asynchrone. Dans notre cas, puisque nous communiquons avec une API backend en utilisant le client HTTP, elle renvoie une observable d'un objet User:

```typescript
import¬†{¬†Injectable¬†}¬†from¬†'@angular/core';
import¬†{¬†Resolve,¬†ActivatedRouteSnapshot,¬†RouterStateSnapshot¬†}¬†from¬†'@angular/router';
import¬†{¬†User}¬†from¬†'./user.model';
import¬†{¬†UserService¬†}¬†from¬†'./user.service';
import¬†{¬†take,¬†mergeMap¬†}¬†from¬†'rxjs/operators';
import¬†{¬†of,¬†Observable¬†}¬†from¬†'rxjs';
@Injectable({
¬†¬†providedIn:¬†'root'
})
export¬†class¬†UserDetailResolverService¬†implements¬†Resolve<User>¬†{
¬†¬†constructor(private¬†userService:¬†UserService)¬†{¬†}
¬†¬†resolve(route:¬†ActivatedRouteSnapshot,¬†state:¬†¬†¬†RouterStateSnapshot):¬†Observable<User>¬†{
¬†¬†¬†¬†const¬†id¬†=¬†+route.paramMap.get('id');
¬†¬†¬†¬†return¬†this.userService.getUser(id).pipe(
¬†¬†¬†¬†¬†¬†take(1),
¬†¬†¬†¬†¬†¬†mergeMap(user=>¬†of(user))
¬†¬†¬†¬†);
¬†¬†}
}
```
La m√©thode de r√©solution pr√©c√©dente comporte plusieurs √©tapes:

1. Tout d'abord, nous obtenons la valeur du param√®tre de route id et la convertissons en un nombre √† l'aide du signe plus.
2. Nous appelons ensuite la m√©thode getUser de UserService, et nous transmettons l'identifiant en param√®tre.
3. Nous utilisons l'op√©rateur pipe pour traiter l'observable retourn√© avec deux autres op√©rateurs RxJS.
4. L'op√©rateur take garantit que l'observable se termine apr√®s l'√©mission de la premi√®re valeur.
5. L'op√©rateur mergeMap est utilis√© pour aplatir l'observable renvoy√©e par la m√©thode getUser.

Un objet de configuration de route contient une propri√©t√© de r√©solution que nous pouvons utiliser pour enregistrer le r√©solveur que nous venons de cr√©er:

```typescript
{
¬†¬†path:¬†'user/:id',
¬†¬†component:¬†UserDetailComponent,
¬†¬†canActivate:¬†[AuthGuard],
¬†¬†canDeactivate:¬†[ConfirmGuard],
¬†¬†resolve:¬†{
¬†¬†¬†¬†hero:¬†UserDetailResolverService
¬†¬†}
}
```
La propri√©t√© de r√©solution est un objet qui contient un nom unique comme cl√© et la classe TypeScript du r√©solveur comme valeur. Le nom de la cl√© est important car nous l'utiliserons dans nos composants pour acc√©der aux donn√©es r√©solues:

```typescript
ngOnInit():¬†void¬†{
¬†¬†this.√πser=¬†this.route.snapshot.data.user;
}
```

Les donn√©es d'un r√©solveur sont disponibles dans la propri√©t√© data de l'objet snapshot. Vous pouvez √©galement vous y abonner directement depuis le service ActivatedRoute:

```typescript
ngOnInit():¬†void¬†{
¬†¬†this.route.data.subscribe((data:¬†{¬†user:¬†User})¬†=>¬†{
¬†¬†¬†¬†this.user=¬†data.user;
¬†¬†});
}
```
Notez que dans les deux cas, les donn√©es r√©solues sont accessibles √† partir de la propri√©t√© user de l'objet de donn√©es. C'est le nom de la cl√© que nous avons d√©fini dans la propri√©t√© resolver de l'objet de configuration d'itin√©raire.

Si vous ex√©cutez l'application maintenant, vous remarquerez qu'il n'y a pas de scintillement lors de la navigation vers HeroDetailComponent, et les d√©tails du user sont affich√©s √† la fois. Cependant, vous remarquerez peut-√™tre un l√©ger retard lors de la s√©lection du user dans la liste. Il s'agit du d√©lai introduit par la requ√™te HTTP √† l'API backend qui provient du r√©solveur.

***
# point-21
### Lazy loading routes

√Ä un moment donn√©, la taille de notre application peut augmenter et la quantit√© de donn√©es que nous y mettons peut √©galement augmenter. Le r√©sultat de ceci est que l'application peut prendre un certain temps pour d√©marrer initialement, ou que certaines parties peuvent prendre beaucoup de temps pour d√©marrer. Pour surmonter ces probl√®mes, nous pouvons utiliser une technique appel√©e chargement paresseux (Lazy loading).

Le chargement diff√©r√© signifie que nous ne chargeons pas toutes les parties de notre application au d√©part. Lorsque nous nous r√©f√©rons √† des pi√®ces, nous entendons des modules angulaires. Les modules d'application peuvent √™tre s√©par√©s en blocs qui ne sont charg√©s qu'en cas de besoin. Le chargement paresseux d'un module dans une application angulaire pr√©sente de nombreux avantages:

* Les modules de fonctionnalit√©s peuvent √™tre charg√©s √† la demande de l'utilisateur.
* Les utilisateurs qui visitent certaines zones de votre application peuvent b√©n√©ficier de mani√®re significative de cette technique.
* Nous pouvons ajouter plus de fonctionnalit√©s dans un module charg√© paresseusement sans affecter la taille globale du bundle d'applications.

Pour d√©voiler pleinement le potentiel du chargement paresseux, ajoutons un nouveau composant dans notre application Angular:

1. Cr√©ez un nouveau module nomm√© about avec le routage activ√©.
2. Cr√©ez un composant nomm√© about-info dans le module nouvellement cr√©√©.
3. Ouvrez le fichier about-routing.module.ts et ajoutez un nouvel objet de configuration d'itin√©raire dans la variable routes pour activer AboutInfoComponent. D√©finissez la propri√©t√© path sur une cha√Æne vide afin que AboutInfoComponent soit activ√© par d√©faut:

```typescript
const¬†routes:¬†Routes¬†=¬†[
¬†¬†{¬†path:¬†'',¬†component:¬†AboutInfoComponent¬†}
];
```
4. Ajoutez un nouvel √©l√©ment d'ancrage au fichier app.component.html qui renvoie √† la route nouvellement cr√©√©e:

```typescript
<nav>
¬†¬†<a¬†routerLink="/users"¬†routerLinkActive=¬†¬†"active">Users</a>
¬†¬†<a¬†routerLink="/about"¬†routerLinkActive="active">About</¬†¬†a>
</nav>
<router-outlet></router-outlet>
```
5. Ajoutez un nouvel objet de configuration de route √† la variable routes de AppRoutingModule. D√©finissez la propri√©t√© path sur about et utilisez la propri√©t√© loadChildren pour pointer vers AboutModule paresseusement:

```typescript
const¬†routes:¬†Routes¬†=¬†[
¬†¬†{¬†path:¬†'about',¬†loadChildren:¬†()¬†=>¬†import('./about/¬†¬†about.module').then(m¬†=>¬†m.AboutModule)},
¬†¬†{¬†path:¬†'**',¬†component:¬†PageNotFoundComponent¬†}
];
```
La propri√©t√© loadChildren renvoie une fonction de fl√®che qui utilise l'instruction d'importation dynamique ES6 pour lazy load AboutModule. La fonction d'importation accepte le chemin relatif du module que nous voulons importer et renvoie un objet de promesse contenant la classe TypeScript du module Angular que nous voulons charger.

>Note importante
>Nous n'avons pas ajout√© AboutModule au tableau des importations d'AppModule. Si nous l'avions fait, AboutModule aurait √©t√© charg√© deux fois: une fois avec impatience depuis AppModule et une autre fois paresseusement √† partir du lien √Ä propos.

L'application lance une nouvelle requ√™te dans le fichier about-about-module.js, qui est l'ensemble d'AboutModule. Le framework Angular cr√©e un nouveau bundle pour chaque module qui est charg√© paresseusement et ne l'inclut pas dans le bundle d'application principal.

Si vous quittez et cliquez √† nouveau sur le lien √Ä propos, vous remarquerez que l'application ne fait pas de nouvelle demande pour charger AboutModule. D√®s qu'un module charg√© tardivement est demand√©, il est conserv√© en m√©moire et peut √™tre utilis√© pour les requ√™tes suivantes.

Un mot d'avertissement, cependant. Un service angulaire est enregistr√© aupr√®s de l'injecteur racine de l'application √† l'aide de la propri√©t√© providedIn du d√©corateur @Injectable. Les modules √† chargement diff√©r√© cr√©ent un injecteur distinct qui est un enfant imm√©diat de l'injecteur d'application racine. Si vous utilisez un service Angular enregistr√© avec l'injecteur d'application racine dans un module √† chargement diff√©r√©, vous vous retrouverez avec une instance distincte du service dans les deux cas. Donc, nous devons √™tre prudents quant √† la fa√ßon dont nous utilisons les services dans les modules charg√©s paresseusement.

Les modules √† chargement diff√©r√© sont des modules angulaires standard, nous pouvons donc contr√¥ler leur acc√®s √† l'aide de gardes.

IMPORTANT [^1]

[^1] La grande proportions de ces notes provient de R√©da Hamza

**R√©flexion sur le projet final**

DIDIER: INFO DE L"AN PASSE A CHANGER

Scrum 

1. D√©finir l'architecture Front (DFD : Diagramme de Flux de donn√©es) [Option de la barre + Routeur de Angular]

* Un menu en barre de navigation ==> Bootstrap, Emmet, FontAwsome, Responsive
* Un pied de page

2. Les options du menu

* CRUD ==> GenericService
 
    * Model ==> Objet, Class, Interface [Combien de mod√®les ?] : Song, Reservation

    * Notion de service : H√©ritage

    * HttpClient et HttpClientModule  ==> '@angular/common/http'

    * Json-server 

* Playlist [Lecteur de vid√©o Youtube]

* Formulaire(s)

* Tutoriel (Projet)
  * Lien vers le TP1
  * Mini tutoriel sur Angular
  * Mini tutoriel sur les commandes Angular
  * Mini tutoriel sur Typescript
  * Mini tutoriel sur les Relations entre les objets

* Pagination

* Home

* Cr√©ativit√©



# üé∂  Travail final

# üåº  Consignes du TP synth√®se
* Ce travail compte pour 20% de la note finale, il s‚Äôagit du travail de synth√®se.
* La date de remise est le vendredi 18 d√©cembre 2020 √† minuit.
* Le travail doit √™tre remis sur L√âA et le Github priv√©, aucune autre m√©thode de remise ne sera accept√©e
* Tout retard dans la remise de ce travail entra√Ænera une p√©nalit√© de 10% par jour de retard jusqu‚Äô√† concurrence de 5 jours. Apr√®s cette date, la note z√©ro sera attribu√©e au travail.

# üåº Contexte du travail pratique
     Dans ce travail pratique vous allez mettre en pratique les notions suivantes :

* La librairie Bootstrap
* La librairie Font Awesome
* La notion de sensibilit√© de l'interface (RESPONSIVE)
* La notion de barre de navigation et pied de page
* Le mod√®le de programmation C.R.U.D.
* La Framework Angular.
* L‚Äôinteraction avec une base de donn√©es.
* La notion de REST webservice.

Pour accomplir ce travail, vous devez r√©aliser les objectifs suivants :
# üåº La liste des objectifs
* :mushroom: [Objectif 1 : la barre de navigation (5 points)](#objectif1)
* :mushroom: [Objectif 2 : le bas de page (5 points)](#objectif2)
* :mushroom: [Objectif 3 : la section page d'accueil (10 points)](#objectif3)
* :mushroom: [Objectif 4 : la section tutorielle (10 points)](#objectif4)
* :mushroom: [Objectif 5 : la section formulaire de type Template (15 points)](#objectif5)
* :mushroom: [Objectif 6 : la section C.R.U.D (35 points)](#objectif6)
* :mushroom: [Objectif 7 : la section F.U.N : exemple : int√©gration du lecteur YOUTUBE](#objectif7)
* :mushroom: [Objectif 8 : la qualit√© du code (10 points)](#objectifTransversal1)
* :mushroom: [Objectif 9 : la qualit√© de l'application (10 points)](#objectifTransversal2)


>### [Lien vers l'API Faker](http://marak.github.io/faker.js/#toc2__anchor)

